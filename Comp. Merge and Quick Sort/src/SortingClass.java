import java.util.Random;

public class SortingClass {

	void merge_sort_2_parts(int arr[], int first, int last) {
		if (first < last) {
			int center = (first + last) / 2;   // İkiye bölüm işlemini yapacağımız merkez noktayı belirleriz.

			merge_sort_2_parts(arr, first, center);     // İlk eleman ve merkeze kadar olan kısım ilk parça, merkezden 1 adım sonraki elemandan son elemana
			merge_sort_2_parts(arr, center + 1, last);     // kadar olan kısım da ikinci parça olur ve bunları yeniden aynı fonksiyonla çağırırız.

			merge_2_parts(arr, first, center, last);   // Dizideki elemanların sıralanması işlemini bu fonksiyon yapar.
		}
	}

	void merge_2_parts(int arr[], int first, int center, int last) {
		int n1 = center - first + 1;   // İlk parçanın eleman sayısı
		int n2 = last - center;        // İkinci parçanın eleman sayısı
		                            
		int F[] = new int[n1];    // Parçaları tutmak için 2 yeni array oluştururuz.
		int L[] = new int[n2];

		for (int i = 0; i < n1; ++i)  // Merkeze kadar olan elemanları ilk arraye,
			F[i] = arr[first + i];    // merkezden sonrakileri ise ikinci arraye atarız.
		for (int j = 0; j < n2; ++j)
			L[j] = arr[center + 1 + j];

		int i = 0, j = 0;    // Açtığımız iki arrayin indexleri

		int k = first;
		while (i < n1 && j < n2) {     // İki arrayde de eleman varsa döngü devam eder. 
			if (F[i] <= L[j]) {       // Hangi arraydeki eleman daha küçükse onu alıp ana arrayde ilk elemanın olduğu yere koyarız.
				arr[k] = F[i];       // Sonra ana arrayin indexi olan k 1 tane büyür ve karşılaştırmaya devam ederek ana arrayi doldururuz.
				i++;
			} else {
				arr[k] = L[j];
				j++;
			}
			k++;
		}

		while (i < n1) {       // Eğer arraylerden birinin eleman sayısı biterse diğer arraydeki elemanlarla devam ederiz. 
			arr[k] = F[i];    
			i++;
			k++;
		}

		while (j < n2) {
			arr[k] = L[j];
			j++;
			k++;
		}
	}

	void merge_sort_3_parts(int arr[], int first, int last) {
		if (first < last) {
			int center_1 = first + (last - first) / 3;       // Bu sefer 3 grup oluşturacağımız için 2 tane noktaya ihtiyacımız var.
			int center_2 = first + 2 * (last - first) / 3;   // Bu işlemlerle grupları eşit bölecek 2 nokta belirliyoruz.

			merge_sort_3_parts(arr, first, center_1);          // Belirlediğimiz noktalar, ilk eleman ve son eleman arasında 3 gruba bölüyoruz.
			merge_sort_3_parts(arr, center_1 + 1, center_2);                           
			merge_sort_3_parts(arr, center_2 + 1, last);

			merge_3_parts(arr, first, center_1, center_2, last);    // Sıralama için yolluyoruz.
		}
	}

	void merge_3_parts(int arr[], int first, int center_1, int center_2, int last) {
		int n1 = center_1 - first + 1;     // Oluşturulan 3 parçanın eleman sayılarını buluyor.
		int n2 = center_2 - center_1;      
		int n3 = last - center_2;        
		                         
		int F[] = new int[n1];   // Her bir parça için yeni birer array oluşturuyoruz.
		int C[] = new int[n2];
		int L[] = new int[n3];

		for (int i = 0; i < n1; ++i)   // Ana arraydeki elemanları hangi grupta olduklarını kontrol ederek yeni arraylere ekliyoruz.
			F[i] = arr[first + i];
		for (int j = 0; j < n2; ++j)
			C[j] = arr[center_1 + 1 + j];
		for (int p = 0; p < n3; ++p)
			L[p] = arr[center_2 + 1 + p];

		int i = 0, j = 0, p = 0;    // Arraylerin indexleri

		int k = first;  // Ana arrayin indexi
		while (i < n1 && j < n2 && p < n3) {  // 3 arrayde de eleman varsa devam ediyor.
			if (F[i] <= C[j] && F[i] <= L[p]) {  // F arrayindeki eleman en küçük mi diye bakarız.
					arr[k] = F[i];   // Eğer en küçük oysa ana arraydeki ilk elemanı değiştirerek sıralamaya başlarız.
					i++;
				}         
			else {       // F en küçük değilse C ve L'dekileri karşılaştırır.
				if (C[j] <= L[p]) {
					arr[k] = C[j];  // C'deki küçükse ana arrayin ilk elemanına o konur.
					j++;
				}
				else {  // Eğer L'deki en küçükse o zaman da ana arrayin ilk elemanına o değer konur.
					arr[k] = L[p];
					p++;
				}
			}
			k++;  // k'yi arttırarak ana arrayi düzenlemeye devam ederiz.
		}
		// Arraylerden biri bittiyse diğer ikisiyle devam etmeliyiz.
		if (i >= n1) {  // Burada if komutlarıyla hangi arrayin bittiğine bakarız.
			while (j < n2 && p < n3) {
				if (C[j] <= L[p]) {   // Sonrasında kalan 2 arrayi karşılaştırarak devam ederiz.
					arr[k] = C[j];
					j++;
				} else {
					arr[k] = L[p];
					p++;
				}
				k++;
			}
		}  
		else if (j >= n2) {
			while (i < n1 && p < n3) {
				if (F[i] <= L[p]) {
					arr[k] = F[i];
					i++;
				} else {
					arr[k] = L[p];
					p++;
				}
				k++;
			}
		}
		else if (p >= n3) {
			while (i < n1 && j < n2) {
				if (F[i] <= C[j]) {
					arr[k] = F[i];
					i++;
				} else {
					arr[k] = C[j];
					j++;
				}
				k++;
			}
		}
        // Geriye tek bir array kalınca onun elemanlarını ana arraye ekleyerek bitiririz.
		while (i < n1) {
			arr[k] = F[i];
			i++;
			k++;
		}

		while (j < n2) {
			arr[k] = C[j];
			j++;
			k++;
		}
		
		while (p < n3) {
			arr[k] = L[p];
			p++;
			k++;
		}
	}
	
	void quick_sort_pivot_first(int[] arr, int first, int last) {
        if (first < last) {
            int pivotIndex = partition_pivot_first(arr, first, last);  // Öncelikle tüm array alınarak bir defa bir sıralama yapılır.
            quick_sort_pivot_first(arr, first, pivotIndex - 1);   // Sonra fonksiyonun döndürdüğü pivot değerine bakılarak 
            quick_sort_pivot_first(arr, pivotIndex + 1, last);   // 2 yeni grup oluşturulup fonksiyonlar yeniden çağrılır.
        }  // Array küçük parçalara ayrılıp kendi içlerinde tekrar tekrar sıralandıktan sonra parçalar birleşir ve sıralı bir array elde ederiz.
    }

    int partition_pivot_first(int[] arr, int first, int last) {
        int pivot = arr[first];    // Burada pivot her zaman arrayin ilk elemanı olarak seçilir.
        int i = first + 1; // i değerini arrayin içindeki değerlerin yerlerini değiştirirken kullanacağız. İlk eleman zaten pivot olduğu için 2.elemandan başlatırız.
        for (int j = i; j <= last; j++) {  // j arrayin içinde gezmek için kullanılıyor ve en başta i ile aynı yerden başlatıyoruz.
            if (arr[j] < pivot) {    // Eğer o an üstünde bulunduğumuz değer pivottan küçükse 
                int temp = arr[j];  // i ve j indexlerinin bulunduğu yerlerdeki sayılar yer değiştirilir.
                arr[j] = arr[i];
                arr[i] = temp;
                i++;  // Her yer değiştirmeden sonra i bir adım sağa kaydırılır.
            }
        }
        int temp = arr[first]; // Tüm array gezildikten sonra i'nin solundaki sayı ile pivot yer değiştirilir.
        arr[first] = arr[i - 1];
        arr[i - 1] = temp; // Arrayi 2 gruba ayırırken kullanmak için i - 1 değerini return ederiz. 
        return i - 1;     // Örnek olarak 3, 12, 8, 4, 1, 9, 7 gibi bir array varsa ve i değeri 3 ise 2 değeri döndürülür ve array 2'nin karşılık geldiği yer olan 8'den bölünür.
    }                    // Böldüğümüz 2 parça 3, 12 ve 4, 1, 9, 7 şeklinde olur.      
    
    void quick_sort_pivot_random(int[] arr, int first, int last) {
        if (first < last) {
            int pivotIndex = partition_pivot_random(arr, first, last);  // pivot_first fonksiyonu ile aynı işlemler yapılır yalnızca birkaç küçük fark bulunuyor.
            quick_sort_pivot_random(arr, first, pivotIndex - 1);
            if(pivotIndex < last)  // Burada önceki fonksiyondan farklı olarak i - 1 değil i değeri döndürülmektedir. 
            	quick_sort_pivot_random(arr, pivotIndex + 1, last);  // Bu yüzden pivotIndex + 1 kısmında arrayin taşmaması için bir kontrol yapılır.
        }
    }

    int partition_pivot_random(int[] arr, int first, int last) {
    	Random random = new Random();  // Fonksiyon içine gönderilen kısımdan random bir index seçilir.
        int rnd = random.nextInt(last - first + 1) + first;
        int pivot = arr[rnd];  // Bu indexe karşılık gelen kısım pivot değerimiz olur. 
        int i = first;  // Bu sefer pivot değerimiz random seçildiği için i'yi başlangıç elemanından başlatırız.
        for (int j = i; j <= last; j++) {
            if (arr[j] < pivot) {
                int temp = arr[j];  // Burada yukarıdakiyle aynı kontrol yapılarak yine i ve j değerleri yer değiştirilir. 
                arr[j] = arr[i];
                arr[i] = temp;
                if(i == rnd)    // Bu fonksiyonda pivot değerin indexini tutmamız gerekiyor 
            		rnd = j;   // bu yüzden i değeri pivot indexine eşitse pivot indexi pivotun yeni yerleştirildiği yer olan j'ye eşitlenir.
                i++;
            }
        }
        
        arr[rnd] = arr[i];  // Bu sefer i'nin üstünde bulunduğu eleman ile pivot yer değiştirilir.
        arr[i] = pivot;
        return i;  // Sonra i değeri return edilir.
    }
    
    void quick_sort_pivot_mid(int[] arr, int first, int last) {
        if (first < last) {
            int pivotIndex = partition_pivot_mid(arr, first, last);
            quick_sort_pivot_mid(arr, first, pivotIndex - 1);
            if(pivotIndex < last) 
            	quick_sort_pivot_mid(arr, pivotIndex + 1, last);
        }
    }

    int partition_pivot_mid(int[] arr, int first, int last) {
    	int mid = (first + last) / 2;   // Arrayin mid, first ve last elemanları karşılaştırılarak üçünün ortasındaki değer pivot olarak seçilir.
    	int mid_of = 0;                // Fonksiyonun geri kalan kısmı üstteki fonksiyon ile tamamen aynı mantıkta çalışmaktadır.
    	                              // Burada da yine seçilen değerin indexi önceden belli olmadığından random için kullandığımız algoritma doğru sonucu vermektedir.
    	if((arr[first] <= arr[mid] && arr[first] >= arr[last]) || (arr[first] <= arr[last] && arr[first] >= arr[mid])) 
    		mid_of = first;
    	if((arr[mid] <= arr[first] && arr[mid] >= arr[last]) || (arr[mid] <= arr[last] && arr[mid] >= arr[first])) 
    		mid_of = mid;
    	if((arr[last] <= arr[mid] && arr[last] >= arr[first]) || (arr[last] <= arr[first] && arr[last] >= arr[mid])) 
    		mid_of = last;
    	
        int pivot = arr[mid_of];
        int i = first;
        for (int j = i; j <= last; j++) {
            if (arr[j] < pivot) {
                int temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
                if(i == mid_of)
            		mid_of = j;
                i++;
            }
        }
        
        arr[mid_of] = arr[i];
        arr[i] = pivot;
        return i;
    }

}
